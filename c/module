/*******************************************************************
 * File:        module
 * Purpose:     KernelIntrospection module interface
 * Author:      Gerph
 ******************************************************************/

#include <stdlib.h>
#include <stdio.h>

#include "kernel.h"
#include "modhead.h"

#include "os.h"
#include "osbyte.h"

// #define DEBUG


#ifdef DEBUG
#define dprintf if (1) printf
#else
#define dprintf if (0) printf
#endif


#ifdef OS_SWIS
#include "osswis.h"

uint32_t registered = 0;
void register_osswis(void *pw, bool reg);
#endif

/***************************************************************************
 * Function:     Mod_Init
 * Description:  Initialise the module, setting up vectors, callbacks and
 *               any other parts of the system necessary for the module to
 *               function.
 * Parameters:   tail        = pointer to command line (control terminated)
 *               podule_base = address of podule module was started from, or
 *                             NULL if none
 *               pw          = private word for module
 * On exit:      Return NULL for successful initialisation, or a pointer to
 *               an error block if the module could not start properly.
 **************************************************************************/
_kernel_oserror *Mod_Init(const char *tail, int podule_base, void *pw)
{
    _kernel_oserror *err;
    err = osbyte_init(pw);
    if (err)
        return err;
#ifdef OS_SWIS
    register_osswis(pw, true);
#endif
    dprintf("Module KernelIntrospection initialised\n");
    return NULL;
}


/***************************************************************************
 * Function:     Mod_Final
 * Description:  Finalise the module, shutting down any systems necessary,
 *               freeing vectors and releasing workspace
 * Parameters:   fatal       = fatality indicator; 1 if fatal, 0 if
 *                             reinitialising
 *               podule_base = address of podule module was started from, or
 *                             NULL if none
 *               pw          = private word for module
 * On exit:      Return 0 for successful finalisation, or a pointer to an
 *               error block if module was not shutdown properly.
 **************************************************************************/
_kernel_oserror *Mod_Final(int fatal, int podule_base, void *pw)
{
    _kernel_oserror *err;
    dprintf("Module KernelIntrospection dying\n");
#ifdef OS_SWIS
    register_osswis(pw, false);
#endif
    err = osbyte_final(pw);
    if (err)
        return err;
    return NULL;
}

#ifdef OS_SWIS
/* OS SWIs */

#define OSSWI(entry, call) \
_kernel_oserror * entry (_kernel_swi_regs *r, void *pw) \
{ \
    return call; \
}

OSSWI(OSSWI_ReadSysInfo, SWI_ReadSysInfo(0, r, pw))
OSSWI(OSSWI_PlatformFeatures, SWI_PlatformFeatures(0, r, pw))


/*************************************************** Gerph *********
 Function:      register_osswis
 Description:   Register all the OS_* SWIs that we provide (or deregister
 Parameters:    pw = the module private word
                reg = true if we're registering, false if we deregister
 Returns:       none
 ******************************************************************/
void register_osswis(void *pw, bool reg)
{
    _kernel_oserror *err;
    int n = 0;

#define REGISTER(swi, entry) \
        if (reg) \
        { \
            err = osswi_claim(true, swi, entry, pw); \
            if (!err) \
            { \
                registered |= (1u<<n); \
            } \
        } \
        else \
        { \
            if (registered & (1u<<n)) \
            { \
                osswi_claim(false, swi, entry, pw); \
                registered &= ~(1u<<n); \
            } \
        } \
        n++;

    REGISTER(OS_ReadSysInfo, Entry_ReadSysInfo);
    REGISTER(OS_PlatformFeatures, Entry_PlatformFeatures);
}

#endif
