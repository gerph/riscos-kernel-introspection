/*******************************************************************
 * File:        osplatformfeatures
 * Purpose:     Implementation of the OS_PlatformFeatures SWI calls
 * Author:      Gerph
 * Date:        21 Dec 2025
 ******************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>

#include "kernel.h"
#include "swis.h"

#include "riscos/OSPlatformFeatures.h"

#include "modhead.h"


//#define DEBUG


#ifdef DEBUG
#define dprintf if (1) printf
#else
#define dprintf if (0) printf
#endif

#ifndef OS_PlatformFeatures_CPUVectorsLocation
#define OS_PlatformFeatures_CPUVectorsLocation           (0x20)
#define OS_PlatformFeatures_CacheInformation             (0x21)
#define OS_PlatformFeatures_CPUFeatures                  (0x22)
#define OS_PlatformFeatures_ReadClearExclusiveMonitor    (0x23)
#define OS_PlatformFeatures_DescribeCPURegisters         (0x40)
#endif

#ifndef OSPlatformFeaturesCode_CPUHasSeparateCaches
#define OSPlatformFeaturesCode_CPUHasSeparateCaches      (1<<5)
//#define OSPlatformFeaturesCode_OperatingSystemIs32Bit    (1<<6)
//#define OSPlatformFeaturesCode_26BitUnavailable          (1<<7)
#define OSPlatformFeaturesCode_CPUHasMExtensions         (1<<8)
#define OSPlatformFeaturesCode_CPUSupportsThumb          (1<<9)
#define OSPlatformFeaturesCode_CPUHasEExtensions         (1<<10)
#define OSPlatformFeaturesCode_CPUHasNoSWP               (1<<11)
#define OSPlatformFeaturesCode_CPUHasLDRSTREX            (1<<12)
#define OSPlatformFeaturesCode_CPUHasCLREX               (1<<13)
#define OSPlatformFeaturesCode_CannotDisableDCache       (1<<14)
#define OSPlatformFeaturesCode_CPUExtendedSmallPages     (1<<15)
#define OSPlatformFeaturesCode_CPUHasNoDWB               (1<<16)
#define OSPlatformFeaturesCode_CPUHasBrokenAborts        (1<<17)
#define OSPlatformFeaturesCode_CPUIsXScale               (1<<18)
#define OSPlatformFeaturesCode_XScaleJTAG                (1<<19)
#define OSPlatformFeaturesCode_HighVectors               (1<<20)
#define OSPlatformFeaturesCode_LargePhysicalRAM          (1<<21)
#define OSPlatformFeaturesCode_NoPhysicalPages           (1<<22)
#define OSPlatformFeaturesCode_InvalidReasonsAreSafe     (1u<<31)
#endif


_kernel_oserror *platformfeatures_readcodefeatures(_kernel_swi_regs *r)
{
    /*
    OS_PlatformFeatures &00 - Read Code Features

    =>  R0 = 0

    <=  R0 = platform feature flags
        R1 = IRQ trigger function, or 0 if no routine is necessary
    */
    _kernel_oserror *err = NULL;
    uint32_t flags = 0;

#ifdef __riscos64
    /* This is approximately correct for RISC OS 64 - options that are not valid for AArch64 are ignored */
    flags |= OSPlatformFeaturesCode_SynchroniseCodeAreasRequired;
    flags |= OSPlatformFeaturesCode_CannotDisableDCache;
    flags |= OSPlatformFeaturesCode_NoPhysicalPages;
    flags |= OSPlatformFeaturesCode_InvalidReasonsAreSafe;
#else
    /* 32bit RISC OS - we've just set every single flag ! */
    flags |= OSPlatformFeaturesCode_SynchroniseCodeAreasRequired;
    flags |= OSPlatformFeaturesCode_IRQTriggerNecessary;
    flags |= OSPlatformFeaturesCode_HardwareVectorsNeed32bitMode;
    flags |= OSPlatformFeaturesCode_PCStoresPlus8;
    flags |= OSPlatformFeaturesCode_DataAbortsEarly;
    flags |= OSPlatformFeaturesCode_CPUHasSeparateCaches;
    flags |= OSPlatformFeaturesCode_OperatingSystemIs32Bit;
    flags |= OSPlatformFeaturesCode_26BitUnavailable;
    flags |= OSPlatformFeaturesCode_CPUHasMExtensions;
    flags |= OSPlatformFeaturesCode_CPUSupportsThumb;
    flags |= OSPlatformFeaturesCode_CPUHasEExtensions;
    flags |= OSPlatformFeaturesCode_CPUHasNoSWP;
    flags |= OSPlatformFeaturesCode_CPUHasLDRSTREX;
    flags |= OSPlatformFeaturesCode_CPUHasCLREX;
    flags |= OSPlatformFeaturesCode_CannotDisableDCache;
    flags |= OSPlatformFeaturesCode_CPUExtendedSmallPages;
    flags |= OSPlatformFeaturesCode_CPUHasNoDWB;
    flags |= OSPlatformFeaturesCode_CPUHasBrokenAborts;
    flags |= OSPlatformFeaturesCode_CPUIsXScale;
    flags |= OSPlatformFeaturesCode_XScaleJTAG;
    flags |= OSPlatformFeaturesCode_HighVectors;
    flags |= OSPlatformFeaturesCode_LargePhysicalRAM;
    flags |= OSPlatformFeaturesCode_NoPhysicalPages;
    flags |= OSPlatformFeaturesCode_InvalidReasonsAreSafe;
#endif

    r->r[0] = flags;
    r->r[1] = 0; /* We don't have any IRQ trigger function */

    return err;
}

_kernel_oserror *platformfeatures_readmmufeatures(_kernel_swi_regs *r)
{
    _kernel_oserror *err = err_NotImplemented;
    return err;
}

_kernel_oserror *platformfeatures_cpuvectorslocation(_kernel_swi_regs *r)
{
    _kernel_oserror *err = err_NotImplemented;
    return err;
}

_kernel_oserror *platformfeatures_cacheinformation(_kernel_swi_regs *r)
{
    /*
    OS_PlatformFeatures &21 - Read cache information

    =>  R0 = 33
        R1 = cache level

    <=  R0 = Cache support:
                b0-2:   Cache type:
                            0:      None
                            1:      Instruction cache
                            2:      Data cache
                            3:      Split I+D cache
                            4:      Unified cache
                            5-7:    Reserved
                b3-31:  Reserved
        R1 = D cache line length in bytes
        R2 = D cache size in bytes
        R3 = I cache line length in bytes
        R4 = I cache size in bytes
    */
    _kernel_oserror *err = err_NotImplemented;
    int cache_level = r->r[1];
    switch (cache_level)
    {
        case 0:
            r->r[0] = (1<<0);        // We have an I cache
            r->r[1] = 0;             // No D cache
            r->r[2] = 0;             // No D cache
            r->r[3] = 4096;          // I cache line is up to a page long (as basic blocks cannot be larger than that)
            r->r[4] = 0xFFFFFFFF;    // I cache could be as large as our whole memory
            err = NULL;
            break;

        case 1:
            r->r[0] = 0;             // No cache - this is the end of the list.
            r->r[1] = 0;
            r->r[2] = 0;
            r->r[3] = 0;
            r->r[4] = 0;
            err = NULL;
            break;

        default:
            break;
    }

    return err;
}

_kernel_oserror *platformfeatures_cpufeatures(_kernel_swi_regs *r)
{
    _kernel_oserror *err = err_NotImplemented;
    return err;
}

_kernel_oserror *platformfeatures_readclearexclusivemonitor(_kernel_swi_regs *r)
{
    _kernel_oserror *err = err_NotImplemented;
    return err;
}


#if ! defined(__riscos64) && defined(__riscos)
#include "cpuregisters_aarch32.h"
#define default_cpu_regs &cpuregisters_aarch32
#endif

#ifdef __riscos64
#include "cpuregisters_aarch64.h"
#define default_cpu_regs &cpuregisters_aarch64
#endif

_kernel_oserror *platformfeatures_describecpuregisters(_kernel_swi_regs *r)
{
    /*
    OS_PlatformFeatures &40 - Describe CPU architecture and registers

    =>  R0 = 64

    <=  R0 = pointer to CPU architecture and registers block:
                +0  Architecture identifier:
                        0   ARM 32 bit (A32)
                        1   ARM 64 bit (A64)
                        2   x86 64 bit (x86-64)
                +4  Minimum instruction length in bytes
                +8  Maximum instruction length in bytes
                +12 Total length of the register dump block
                +16... register definitions:
                        +0  -1 if end of list,
                            definition type in bit 24-30, definition specific data in bits 0-23. types:
                                0:  register definition, specific data is:
                                    logical register number (maps to ARM 32 registers)
                                1:  flag definition for prior register
                                        b0-7:   base bit number (values 0-255)
                                        b8-21:  value described (if bit 23 set)
                                        b22-23: 0 => this is the flag name (or name of the region if multiple bits)
                                                1 => this is the flag name and values follow
                                                2 => this is a flag value, and no values follow
                                                3 => this is a flag value, and more values follow
                        +4  offset from base of architecture register block to descriptive name
                        +8  offset of value in the register dump block, or -1 if not present in dump block
                        +12 register flags:
                                b0-11:  Register/Flag: size in bits
                                b12-15: Register: register type:
                                            0: general purpose register
                                            1: stack pointer
                                            2: link register
                                            3: program counter
                                            4: state flags
                                            5-15: reserved
                                b16-23: bit alignment (eg
                                                       0 for byte alignment,
                                                       2 for 4 byte (word) alignment,
                                                       4 for 16 byte alignment)
                                b24-31: reserved
    */
    _kernel_oserror *err = NULL;
    r->r[0] = (uint32_t)default_cpu_regs;
    return err;
}



/***************************************************************************
 * Description:  SWI handler routine. All SWIs for this module will be
 *               passed to these routines.
 * Parameters:   number = SWI number within SWI chunk (i.e. 0 to 63)
 *               r      = pointer to register block on entry
 *               pw     = private word for module
 * On exit:      Return NULL if SWI handled successfully, setting return
 *               register values (r0-r9) in r.
 *               Return error_BAD_SWI for out of range SWIs.
 *               Return an error block for a custom error.
 **************************************************************************/
/* Functions called to handle particular SWI calls */
_kernel_oserror *SWI_PlatformFeatures(int number, _kernel_swi_regs *r, void *pw)
{
    _kernel_oserror *err = err_NotImplemented;
    int reason = r->r[0];

    dprintf("OS_PlatformFeatures #%i\n", reason);

    switch (reason)
    {
        case OS_PlatformFeatures_ReadCodeFeatures:
            err = platformfeatures_readcodefeatures(r);
            break;

        case OS_PlatformFeatures_ReadMMUFeatures:
            err = platformfeatures_readmmufeatures(r);
            break;

        case OS_PlatformFeatures_CPUVectorsLocation:
            err = platformfeatures_cpuvectorslocation(r);
            break;

        case OS_PlatformFeatures_CacheInformation:
            err = platformfeatures_cacheinformation(r);
            break;

        case OS_PlatformFeatures_CPUFeatures:
            err = platformfeatures_cpufeatures(r);
            break;

        case OS_PlatformFeatures_ReadClearExclusiveMonitor:
            err = platformfeatures_readclearexclusivemonitor(r);
            break;

        case OS_PlatformFeatures_DescribeCPURegisters:
            err = platformfeatures_describecpuregisters(r);
            break;

        default:
        /* FIXME: Should be Bad PlatformFeatures */
            err = err_NotImplemented;
            break;
    }
    return err;
}
